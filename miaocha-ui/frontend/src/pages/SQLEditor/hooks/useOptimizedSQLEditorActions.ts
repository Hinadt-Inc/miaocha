import { useCallback, useRef, useEffect, useMemo } from 'react';
import { message } from 'antd';
import { debounce } from 'lodash';
import copy from 'copy-to-clipboard';
import * as monaco from 'monaco-editor';
import { downloadAsCSV, insertTextToEditor, getSQLContext } from '../utils/editorUtils';
import { QueryResult } from '../types';
import { useSQLCompletion } from './useSQLCompletion';
import type { useOptimizedSQLEditorState } from './useOptimizedSQLEditorState';

type OptimizedSQLEditorState = ReturnType<typeof useOptimizedSQLEditorState>;

/**
 * ‰ºòÂåñÁöÑSQLÁºñËæëÂô®Êìç‰ΩúÁÆ°ÁêÜHook
 * ÊîØÊåÅÊñ∞ÁöÑÊï∞ÊçÆÂ∫ìÁªìÊûÑÁÆ°ÁêÜ
 */
export const useOptimizedSQLEditorActions = (editorState: OptimizedSQLEditorState) => {
  const {
    selectedSource,
    sqlQuery,
    setSqlQuery,
    executeQueryOriginal,
    setActiveTab,
    setXField,
    setYField,
    editorRef,
    monacoRef,
    saveSettings,
    fetchDatabaseSchema,
    fetchDatabaseTables,
    fetchTableSchema,
    databaseSchema,
  } = editorState;

  // ÂàùÂßãÂåñ SQL Ë°•ÂÖ®ÂäüËÉΩÔºåÂÖºÂÆπÊâ©Â±ïÁöÑÊï∞ÊçÆÂ∫ìÁªìÊûÑ
  const compatibleSchema = useMemo(() => {
    if (!databaseSchema) return null;
    if ('error' in databaseSchema) return null;
    
    // ËΩ¨Êç¢‰∏∫ÂÖºÂÆπÁöÑÊ†ºÂºè
    return {
      databaseName: databaseSchema.databaseName,
      tables: databaseSchema.tables
        .filter(table => table.columns && table.columns.length > 0)
        .map(table => ({
          tableName: table.tableName,
          tableComment: table.tableComment,
          columns: table.columns || [],
        })),
    };
  }, [databaseSchema]);

  const { registerCompletionProvider } = useSQLCompletion(compatibleSchema);
  const completionProviderRef = useRef<monaco.IDisposable | null>(null);

  // ËÆ°ÁÆóSQLËØ≠Âè•Êï∞ÈáèÁöÑËæÖÂä©ÂáΩÊï∞
  const countSQLStatements = useCallback((text: string): number => {
    if (!text.trim()) return 0;

    // ÁßªÈô§Ê≥®ÈáäÂíåÂ≠óÁ¨¶‰∏≤‰∏≠ÁöÑÂàÜÂè∑ÔºåÈÅøÂÖçËØØÂà§
    let cleanText = text;

    // ÁßªÈô§ÂçïË°åÊ≥®Èáä
    cleanText = cleanText.replace(/--.*$/gm, '');

    // ÁßªÈô§Â§öË°åÊ≥®Èáä
    cleanText = cleanText.replace(/\/\*[\s\S]*?\*\//g, '');

    // ÁßªÈô§Â≠óÁ¨¶‰∏≤‰∏≠ÁöÑÂàÜÂè∑ÔºàÁÆÄÂçïÂ§ÑÁêÜÔºâ
    cleanText = cleanText.replace(/'[^']*'/g, '');
    cleanText = cleanText.replace(/"[^"]*"/g, '');

    // ÊåâÂàÜÂè∑ÂàÜÂâ≤Âπ∂ËÆ°ÁÆóÊúâÊïàËØ≠Âè•
    const statements = cleanText
      .split(';')
      .map((stmt) => stmt.trim())
      .filter((stmt) => stmt.length > 0);

    return statements.length;
  }, []);

  // Ê£ÄÊü•SQLËØ≠Ê≥ïÊúâÊïàÊÄß
  const validateSQL = useCallback((query: string): boolean => {
    if (!query.trim()) {
      message.warning('ËØ∑ËæìÂÖ•SQLÊü•ËØ¢ËØ≠Âè•');
      return false;
    }
    return true;
  }, []);

  // Èò≤ÊäñÊâßË°åÊü•ËØ¢ÁöÑÂÜÖÈÉ®ÂáΩÊï∞
  const executeQueryInternal = useCallback(() => {
    try {
      if (!selectedSource) {
        message.warning('ËØ∑ÂÖàÈÄâÊã©Êï∞ÊçÆÊ∫ê');
        return;
      }

      // Ëé∑ÂèñË¶ÅÊâßË°åÁöÑSQLËØ≠Âè•
      let queryToExecute = '';

      if (editorRef.current) {
        const selection = editorRef.current.getSelection();
        const model = editorRef.current.getModel();
        if (model) {
          const fullText = model.getValue();

          // Ê£ÄÊü•ÊòØÂê¶ÊúâÈÄâ‰∏≠ÊñáÊú¨
          if (selection && !selection.isEmpty()) {
            queryToExecute = model.getValueInRange(selection);
          } else {
            const statementCount = countSQLStatements(fullText);

            if (statementCount === 1) {
              queryToExecute = fullText;
            } else if (statementCount > 1) {
              message.warning('Ê£ÄÊµãÂà∞Â§öÊù°SQLËØ≠Âè•ÔºåËØ∑ÈÄâ‰∏≠Ë¶ÅÊâßË°åÁöÑËØ≠Âè•');
              return;
            } else {
              queryToExecute = fullText;
            }
          }
        }
      }

      // Â¶ÇÊûúÁºñËæëÂô®Ëé∑Âèñ‰∏çÂà∞ÂÜÖÂÆπÔºåÂàô‰ΩøÁî®Áä∂ÊÄÅ‰∏≠ÁöÑ sqlQuery
      if (!queryToExecute.trim()) {
        queryToExecute = sqlQuery;
      }

      // ËøáÊª§ÊéâÁªìÂ∞æÁöÑÊç¢Ë°åÁ¨¶ÔºåÈÅøÂÖçÊé•Âè£Êä•Èîô
      queryToExecute = queryToExecute.replace(/\n+$/, '');

      // È™åËØÅSQLÈùûÁ©∫
      if (!validateSQL(queryToExecute)) return;

      // Ëá™Âä®Ê∑ªÂä†ÂàÜÂè∑
      if (queryToExecute.trim() && !queryToExecute.trim().endsWith(';')) {
        queryToExecute = queryToExecute + ';';
      }

      setActiveTab('results');

      executeQueryOriginal({
        datasourceId: selectedSource,
        sql: queryToExecute,
        selectedText: queryToExecute,
        editor: editorRef.current,
      })
        .then((results: QueryResult) => {
          if (results?.rows?.length && results?.columns) {
            setXField(results.columns[0]);
            const numericColumn = results.columns.find((col: string) => {
              const sampleValue = results.rows?.[0][col];
              return typeof sampleValue === 'number';
            });
            setYField(numericColumn ?? results.columns[1] ?? results.columns[0]);
          }
        })
        .catch((error: Error) => {
          console.error('ÊâßË°åÊü•ËØ¢Â§±Ë¥•:', error);
          message.error(`ÊâßË°åÊü•ËØ¢Â§±Ë¥•: ${error.message}`);
        });
    } catch (error) {
      console.error('ÊâßË°åÊü•ËØ¢ËøáÁ®ã‰∏≠ÂèëÁîüÊú™ÊçïËé∑ÁöÑÂºÇÂ∏∏:', error);
      message.error('ÊâßË°åÊü•ËØ¢Êó∂ÂèëÁîüÊú™Áü•ÈîôËØØ');
    }
  }, [
    selectedSource,
    sqlQuery,
    countSQLStatements,
    validateSQL,
    setActiveTab,
    executeQueryOriginal,
    setXField,
    setYField,
  ]);

  // ‰ΩøÁî®Èò≤ÊäñÁöÑÊü•ËØ¢ÊâßË°å
  const debouncedExecuteQuery = useMemo(() => debounce(executeQueryInternal, 300), [executeQueryInternal]);

  // Ê∏ÖÁêÜÈò≤ÊäñÂáΩÊï∞
  useEffect(() => {
    return () => {
      debouncedExecuteQuery.cancel();
    };
  }, [debouncedExecuteQuery]);

  const executeQuery = useCallback(() => {
    debouncedExecuteQuery();
  }, [debouncedExecuteQuery]);

  // ‰∏ãËΩΩÊü•ËØ¢ÁªìÊûú‰∏∫ CSV
  const handleDownloadResults = useCallback(() => {
    const { queryResults } = editorState;
    if (!queryResults?.rows?.length || !queryResults.columns) {
      message.warning('Ê≤°ÊúâÂèØ‰∏ãËΩΩÁöÑÁªìÊûú');
      return;
    }

    try {
      if (!selectedSource || !sqlQuery) {
        message.warning('Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞');
        return;
      }

      downloadAsCSV(selectedSource, sqlQuery, 'csv');
      message.success('‰∏ãËΩΩÂ∑≤ÂºÄÂßã');
    } catch (error) {
      console.error('‰∏ãËΩΩÂ§±Ë¥•:', error);
      message.error('‰∏ãËΩΩÂ§±Ë¥•');
    }
  }, [editorState, selectedSource, sqlQuery]);

  // ‰ªéÂéÜÂè≤ËÆ∞ÂΩïÂä†ËΩΩÊü•ËØ¢
  const loadFromHistory = useCallback(
    (historySql: string) => {
      setSqlQuery(historySql);
      if (editorRef.current) {
        insertTextToEditor(editorRef.current, historySql);
      }
      message.success('Â∑≤Âä†ËΩΩÂéÜÂè≤Êü•ËØ¢');
    },
    [setSqlQuery],
  );

  // Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø
  const copyToClipboard = useCallback((text: string) => {
    if (copy(text)) {
      message.success('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
    } else {
      message.error('Â§çÂà∂Â§±Ë¥•');
    }
  }, []);

  // Â§ÑÁêÜÁºñËæëÂô®ÊåÇËΩΩ
  const handleEditorDidMount = useCallback(
    (editor: monaco.editor.IStandaloneCodeEditor, monaco: typeof import('monaco-editor')) => {
      editorRef.current = editor;
      monacoRef.current = monaco;

      // Ê∑ªÂä†Âø´Êç∑ÈîÆÔºöCtrl+Enter ÊâßË°åÊü•ËØ¢
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
        executeQuery();
      });

      // Á´ãÂç≥Ê≥®ÂÜåSQLË°•ÂÖ®ÂäüËÉΩÔºàÂç≥‰ΩøÊ≤°ÊúâÊï∞ÊçÆÂ∫ìÁªìÊûÑ‰πüÊèê‰æõÂü∫Á°ÄË°•ÂÖ®Ôºâ
      if (completionProviderRef.current) {
        completionProviderRef.current.dispose();
      }
      completionProviderRef.current = registerCompletionProvider();
      console.log('‚úÖ SQLË°•ÂÖ®Êèê‰æõÂô®Â∑≤Ê≥®ÂÜå');
    },
    [registerCompletionProvider, executeQuery],
  );

  // ÁõëÂê¨Êï∞ÊçÆÂ∫ìÁªìÊûÑÂèòÂåñÔºåÈáçÊñ∞Ê≥®ÂÜåË°•ÂÖ®Êèê‰æõÂô®
  useEffect(() => {
    if (editorRef.current && monacoRef.current) {
      // ÂΩìÊï∞ÊçÆÂ∫ìÁªìÊûÑÂèòÂåñÊó∂ÔºåÈáçÊñ∞Ê≥®ÂÜåË°•ÂÖ®Êèê‰æõÂô®‰ª•Ëé∑ÂèñÊúÄÊñ∞ÁöÑË°®ÂíåÂ≠óÊÆµ‰ø°ÊÅØ
      if (completionProviderRef.current) {
        completionProviderRef.current.dispose();
      }
      completionProviderRef.current = registerCompletionProvider();
      console.log('üîÑ SQLË°•ÂÖ®Êèê‰æõÂô®Â∑≤Êõ¥Êñ∞ÔºàÊï∞ÊçÆÂ∫ìÁªìÊûÑÂèòÂåñÔºâ');
    }
  }, [compatibleSchema, registerCompletionProvider]);

  // Ê∏ÖÁêÜË°•ÂÖ®Êèê‰æõÂô®
  useEffect(() => {
    return () => {
      if (completionProviderRef.current) {
        completionProviderRef.current.dispose();
        completionProviderRef.current = null;
        console.log('üßπ SQLË°•ÂÖ®Êèê‰æõÂô®Â∑≤Ê∏ÖÁêÜ');
      }
    };
  }, []);

  // ‰øùÂ≠òÁºñËæëÂô®ËÆæÁΩÆ
  const saveEditorSettings = useCallback(
    (settings: any) => {
      saveSettings(settings);
      message.success('ËÆæÁΩÆÂ∑≤‰øùÂ≠ò');
    },
    [saveSettings],
  );

  // ÊèíÂÖ•SQLÁâáÊÆµ
  const insertSnippet = useCallback((snippet: string) => {
    if (editorRef.current) {
      const position = editorRef.current.getPosition();
      if (position) {
        editorRef.current.executeEdits('insert-snippet', [
          {
            range: new (editorRef.current.getModel()?.constructor as any).Range(
              position.lineNumber,
              position.column,
              position.lineNumber,
              position.column,
            ),
            text: snippet,
            forceMoveMarkers: true,
          },
        ]);
        editorRef.current.focus();
      }
    }
  }, []);

  // ÊèíÂÖ•Â≠óÊÆµÂêç
  const handleInsertField = useCallback(
    (fieldName: string) => {
      if (editorRef.current) {
        const position = editorRef.current.getPosition();
        const model = editorRef.current.getModel();
        if (position && model) {
          const context = getSQLContext(editorRef.current);
          let textToInsert = fieldName;

          // ÁÆÄÂåñÁöÑÊèíÂÖ•ÈÄªËæë
          if (context.isInSelectClause) {
            textToInsert = fieldName;
          }

          insertTextToEditor(editorRef.current, textToInsert);
          message.success(`Â∑≤ÊèíÂÖ•Â≠óÊÆµ: ${textToInsert}`);
        }
      }
    },
    [],
  );

  // ÂÖºÂÆπÁöÑÊèíÂÖ•Ë°®Êìç‰Ωú - ÊîØÊåÅÈöèÊó∂ÊèíÂÖ•Ë°®ÂêçÔºåÊó†ÈúÄÈ¢ÑÂÖàÂä†ËΩΩÂàó‰ø°ÊÅØ
  const handleInsertTable = useCallback(
    (tableName: string, _columns?: {
        columnName: string;
        dataType: string;
        columnComment: string;
        isPrimaryKey: boolean;
        isNullable: boolean;
      }[]) => {
      if (editorRef.current) {
        const context = getSQLContext(editorRef.current);
        let textToInsert = tableName;

        // Ê†πÊçÆ‰∏ä‰∏ãÊñáÊô∫ËÉΩÊèíÂÖ•
        if (context.isInFromClause) {
          // Âú®FROMÂ≠êÂè•‰∏≠ÔºåÂè™ÊèíÂÖ•Ë°®Âêç
          textToInsert = tableName;
        } else {
          // Âú®ÂÖ∂‰ªñ‰ΩçÁΩÆÔºåÊèíÂÖ•ÂÆåÊï¥ÁöÑSELECTËØ≠Âè•
          // Ê≥®ÊÑèÔºö_columnsÂèÇÊï∞‰øùÁïôÊòØ‰∏∫‰∫ÜÂêëÂêéÂÖºÂÆπÔºåÂΩìÂâçÁâàÊú¨Áªü‰∏Ä‰ΩøÁî®SELECT * FROM
          textToInsert = `SELECT * FROM ${tableName}`;
        }

        insertTextToEditor(editorRef.current, textToInsert);
        message.success(`Â∑≤ÊèíÂÖ•Ë°®: ${tableName}`);
      }
    },
    [],
  );

  // ÂàÜÈ°µÂ§ÑÁêÜ
  const handlePaginationChange = useCallback(
    (page: number, pageSize: number) => {
      editorState.handlePaginationChange(page, pageSize);
    },
    [], // ÁßªÈô§editorState‰æùËµñÔºåÂõ†‰∏∫handlePaginationChangeÂáΩÊï∞ÂºïÁî®Â∫îËØ•ÊòØÁ®≥ÂÆöÁöÑ
  );

  return {
    // Âü∫Á°ÄÊìç‰Ωú
    executeQuery,
    handleDownloadResults,
    loadFromHistory,
    copyToClipboard,

    // ÁºñËæëÂô®Êìç‰Ωú
    handleEditorDidMount,
    saveEditorSettings,
    insertSnippet,
    handleInsertField,
    handleInsertTable,

    // Êï∞ÊçÆÂ∫ìÊìç‰Ωú
    fetchDatabaseSchema,
    fetchDatabaseTables,
    fetchTableSchema,

    // ÂàÜÈ°µ
    handlePaginationChange,

    // Áä∂ÊÄÅËÆæÁΩÆ
    setSelectedSource: editorState.setSelectedSource,
    setSqlQuery,
    setActiveTab,
    setChartType: editorState.setChartType,
    setXField,
    setYField,
    setHistoryDrawerVisible: editorState.setHistoryDrawerVisible,
    setSettingsDrawerVisible: editorState.setSettingsDrawerVisible,
  };
};
